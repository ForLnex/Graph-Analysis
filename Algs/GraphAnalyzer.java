import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import Java.util.List;
import java.util.Set;

/*
 * Constructed by passing in a root node for the graph (A starting location for all
 * of the graph analysis).
 *
 * Stores cycles found in the graph in foundCycles, which can be obtained by calling
 * getCycles().
 *
 * If foundCycles has not been initialized before a call to
 * getCycles(), getCycles() will call findCycles(), which finds cycles in the graph
 * and populates foundCycles with Strings representing those cycles.
 */
public class GraphAnalyzer{
	public final Node ROOT;
	private List<String> foundCycles;

	public GraphAnalyzer(Node root){
		this.ROOT = root;
	}

	public List<String> getCycles(){
		if (this.foundCycles == null)
			findCycles();
		return this.foundCycles();
	}

	//Initializes collections for the depth-first search.
	private void findCycles(){
		Deque<Node> currentPath = new ArrayDeque<Node>();
		Set<Node> visited = new HashSet<Node>();
		foundCycles = new ArrayList<String>();

		cyclesDFS(ROOT, currentPath, visited);
	}

	//Fills foundCycles with Strings generated by makeCycleString()
	//representing cycles found in the graph.
	private void cyclesDFS(Node current, Deque<Node> currentPath, Set<Node> visited){
		currentPath.push(current);

		if (visited.contains(current)){
			foundCycles.add(makeCycleString(currentPath));
			currentPath.pop();
			return;
		}else{
			visited.add(current);
			for (Node n : current.getAdjacent())
				cyclesDFS(n, currentPath, visited);
		}

		currentPath.pop();
		visited.remove(current);
	}

	//Constructs a String that represents the path passed in, e.g. "A => B => C => B".
	private String makeCycleString(Deque<Node> path){
		StringBuilder cycleStringBuilder = new StringBuilder();

		for (Node n : path)
			cycleStringBuilder.append(" => " + n.toString());

		return cycleStringBuilder.toString();
	}
}
